
current version of java:-
java 22

Q1. What do you mean by JIT?
-->
JIT stands for Just-in-Time compiler and is a part of JRE(Java Runtime Environment).
It is used for better performance of the Java applications during run-time.
The step-by-step working process of JIT is mentioned below:

i)Source code is compiled with Javac compiler to form bytecode
ii)Bytecode is further passed on to JVM. The .class files are loaded at run time by JVM and with the help of an interpreter,
    these are converted to machine-understandable code.
iii)JIT is a part of JVM. When the JIT compiler is enabled, the JVM analyzes the method calls in the .class files and compiles them to get more efficient and native machine code at run time.
    It also ensures that the prioritized method calls are optimized.
iv)The JVM then executes the optimized code directly instead of interpreting it again, which increases the performance and speed of the execution.


Q2. what are classloader ?  LOAD(classes & interfaces) --> JVM
-->
Java Classloader is the program of JRE (Java Runtime Environment).
**The task of ClassLoader is to dynamically load the required Java classes and interfaces to the JVM during the execution of the bytecode.
Because of classloaders, the Java run time system does not need to know about files and file systems.

Q3. What is a Class Variable?
-->
Class variables also known as static variable are declared with the static keyword in a class, but outside a method, constructor or a block.
There would only be one copy of each class variable per class, regardless of how many objects are created from it.

Q4. do constructors can be inherited or not in java
-->
No,
-   constructors cannot be inherited in Java. Inheritance in Java allows a subclass to inherit fields and methods from its superclass
   , but constructors are not inherited because they are not members of the class.
-   However, a subclass can call the superclass's constructor using the super() keyword, which must be the first line in the subclass constructor.
     This allows the subclass to initialize the superclass part of the object.

Q5. where does heap and stack memory located?
-->
RAM memory

Q6 .types of variables ?
-->

1.local        :- Lvariables are created within a method and should be accessed within a particular method.
2.static       :- declared outside the main method but inside the class by using static keyword.. Globally accessible in same class.
3.non static   :- Object creation is mandatory to access the nsv.
4.ref          :-

Q7. Constructor chaining?
-->
objects created in the constructor can be used to call the other constructor by using this() or by creating new object into it.

Q8. Question: What is constructor chaining? How can you implement it within the same class and across different classes?
Answer:
       Constructor chaining is calling one constructor from another constructor within the same class using this() or calling a superclass constructor using super().
       It ensures proper initialization of an object.

Q9 .Can this keyword be used in static methods? Why or why not?
-->
 No, this cannot be used in static methods because this refers to an instance of the class
     , and static methods do not belong to any instance—they belong to the class itself.

Q10. primitive data types in java?
-->
char,byte,short,int,float,double,long

Q11. non primitive data type in java?
-->
arrays,class, interface, enum,Strings.

Q.12 Types of functional interfaces ?
-->
i) consumer :
  The Consumer functional interface in Java is a key part of the java.util.function package.
  It represents an operation that takes a single input argument and returns no result.
  Method :-- void accept(T t);
  Usage  :-  forEach() ,peek()  ,,,peek method is often used for debugging purposes
ii)supplier :
  It represents a supplier of results, meaning it can provide an output without needing any input.
  Method :- get()
  usage  :- generate() ,findAny().orElseGet(supplier) ,findById(id).orElseThrow(),findById(id).orElseGet()
iii)function :
    Method:-- map(),flatMap(),Collectors.toMap(), Collectors.mapping()
    flatmap,... Transforms each element into a stream of new values and flattens these streams into a single stream.
iv)Predicate:-
   method:-  filter()

Q.13 Date and Time apis in java difference before java 8 and after java 8.
-->
Old API:
Mutable: The Date object can be changed after it's created.
Complexity: We have to use both Date and Calendar to perform operations like adding days.
Less Readable: The code involves more steps and is harder to follow.

New API:
Immutable: The LocalDateTime object is immutable, so it cannot be changed once it's created.
Simple and Readable: Adding days is straightforward using plusDays(), and the code is easier to understand.
The new API is thread-safe, making it safe to use in multi-threaded applications.

eg:- getting the current date and time, and then adding 5 days to it.

        Date date= new Date();
		System.out.println(date);

		Calendar cal = Calendar.getInstance();
		cal.setTime(date);
		cal.add(cal.DAY_OF_MONTH, 5);
		Date futureDate = cal.getTime();
		System.out.println(futureDate);             //required this much of code

//		New one-->
		LocalDateTime now = LocalDateTime.now();
		LocalDateTime future = now.plusDays(5);
		System.out.println(future);

Q.14 . in which package LocalDate present & also Date is present in which package?
-->
import java.time.LocalDate;

import java.util.Date;

Q15. methods in LocalDate?
-->
 isLeapYear() ,isAfter(LocalDate other) ,isBefore(LocalDate other) ,of(int year, int month, int dayOfMonth) :creates instance of LocalDate
 plusDays(long daysToAdd) , minusDays(long daysToSubtract)

Q. where we need to use complete methods in interface?
-->
interfaces can store complete methods inside private,static and default keyword .

Q16. serialization and deserialization . (in microservice)
-->
A controller method might automatically serialize a Java object to JSON when sending a response:

@GetMapping("/user/{id}")
public User getUser(@PathVariable Long id) {
    return userService.findById(id); // Automatically serialized to JSON
}

When receiving a request, the framework deserializes the JSON payload into a Java object:

@PostMapping("/user")
public void createUser(@RequestBody User user) {
    userService.save(user); // User object is deserialized from JSON
}

Q 17 .thread executor.
-->
ExecutorService is used to manage the execution of tasks in a multithreaded environment,
making it easier to work with threads by providing a higher-level API for task execution, scheduling, and resource management.

Q 18. Inter-Thread Communication
-->
wait(), notify(), and notifyAll():
These methods are used for communication between threads that share a common resource.
A thread can call wait() to pause its execution until another thread calls notify() or notifyAll() on the same object.

Q 19. wrapper class methods.
-->
static methods :- MAX_VALUE, SIZE (will be in bits), parseInt(i) ,toBinaryString(i) ,...
non            :- longValue() ,floatValue() ,...

Q20 .object class methods.
-->
wait(), notify(), toString() ,clone() ,equals(Object obj) ,hashCode()

Q21. finalize .
-->
deprecated in java 9 and fully removed from java in java18
alternative :- try with resources to perform close operations.

Q22. why java is not 100 percent object oriented language
-->
bcoz for accessing static members we are not creating objects ,and another reason will be primitive data types .
for fully object oriented all the operations should happen with the creation of objects only.

Q23. cloning .
-->
creating replica of object .
With cloned objects, you can perform operations like modifying the state of the clone without affecting the original object, testing changes in an isolated environment, or passing the clone to different methods to avoid unintended side effects. Cloning is particularly useful when you need a separate instance that mirrors the original but can be independently altered.

Q24. why we override equals and hashcode methods.
-->
To avoid adding duplicate data

What happens if we don't override hashCode()?
If you don’t override hashCode(), even if two objects are "equal," they might not work correctly in collections like HashMap or HashSet. You could end up with duplicates or missing data.

Why override equals()?
We override equals() to check if two objects are the same based on their values, not just their memory address.


Why override hashCode()?
We override hashCode() so that objects that are considered equal by equals() have the same code and can work correctly in collections like HashMap or HashSet.
if we dont do this then hashcode will be different for same object and will get stored in some other bucket.

Q.. current versions of springboot:-
-->
3.4
Spring Boot 1.x

1.0.0.RELEASE: April 2014
1.1.x - 1.5.x: Released between 2014 and 2017, with 1.5.22 being the last 1.x release (July 2019).
End of Life: Spring Boot 1.x reached its end of life in August 2019.
Spring Boot 2.x

2.0.0.RELEASE: March 2018
2.1.x - 2.7.x: Released between 2018 and 2022.
2.7.x: Last minor version in the 2.x series (May 2022). The 2.x branch continues to receive maintenance updates.
End of Life: Spring Boot 2.x is still under maintenance but is considered legacy as the focus shifts to 3.x.
*Spring Boot 2.x was built on top of Spring Framework 5.x.

3.0.0.RELEASE: November 2022
3.1.x - 3.4.x: Released between 2023 and 2024, with continued active development.
3.5.x and Beyond: Spring Boot 3.x is actively being developed, with new versions expected to follow.
*Requires Java 17+ (LTS).
*Fully supports Spring Framework 6.x.

Spring Boot 2.x -> Spring Framework 5.x.
Spring Boot 3.x -> Spring Framework 6.x.

Q. difference between 2 vs 3 version of springboot?
-->



Q. csrf and cors?
CSRF (Cross-Site Request Forgery)
What it is: CSRF is an attack where a malicious website tricks a user into making unintended requests to another site where they're already authenticated (like their banking site).
Example: Imagine you're logged into your bank's website. If you visit a malicious site, it could secretly send a request to your bank (using your logged-in session) to transfer money, without you realizing it.
Why we disable it: In many APIs (especially stateless ones), we use tokens like JWT instead of relying on sessions, so CSRF isn't a big risk. That's why it's often disabled in APIs.
CORS (Cross-Origin Resource Sharing)
What it is: CORS is a security feature in web browsers that prevents websites from making requests to a different domain (or origin) unless the server allows it.
Example: If your website (myapp.com) tries to make a request to another domain (like api.othersite.com), the browser checks if api.othersite.com allows requests from myapp.com. If not, the browser blocks the request.
Why we disable it: In some cases, we may handle this restriction elsewhere, or we may want to allow requests from any origin, especially in APIs that are used by different front-end clients.
In short:

CSRF prevents malicious sites from tricking users into sending unwanted requests.
CORS controls which websites can make requests to your server.

Q. in how many ways we can iterate/traverse over any list,set,...?
-->
eg:-
ArrayList<String> names = new ArrayList<String>();
        names.add("Durgesh");
        names.add("Sitara");
        names.add("Roshni");
        names.add("Vandna");
        names.add("Vandna");
        names.add("ABC");

solution:-- we can iterate in so many ways like :-
     1. Iterator<T>      :- for forward traversing [ itr.hasNext(), itr.next() ]
     2. ListIterator<T>  :- for both backward and forward  [ listIterator() , listIterator(pass the size here), itr.hasPrevious(), itr.previous()  ]
     3. for loop
     4. for each


Q. how comparable & comparator works?
-->
comparable uses:- compareTo(T o1)
comparator uses:- compare(T o1, T o2)

only it should be -ve then it is perfectly sorted
if +ve then it should be swapped

 during comparing with compareTo(Object o) method:-

if this is greater than given object then it is +ve and cannot be changed.

if +ve then swap
if -ve then keep it


 if object is less    than current object(this) then it is -ve
 if object is greater than current object(this) then it is +ve , sorting will be done here
  if object same then 0

comparator uses compare(Object o1,Object o2); method for comparision

Q.terminal operators:-
forEach();

Q. lazy vs eager. (travelpractise2)
-->
Lazy Loading: Loads data only when accessed. Good for performance if you don't need all related data immediately.
In Practice: When you load an object from the database, related data is not fetched until you specifically ask for it.
For example, if you have a User with a list of Orders, the orders are fetched only when you try to access them.

Eager Loading: Loads all related data upfront. Useful when you know you'll need the related data immediately but can lead to inefficiencies if not managed carefully.
In Practice: When you load an object from the database, all its related data is fetched right away.
             For example, if you load a User, their orders are fetched at the same time.

Q. save vs saveAndFlush().
-->
save(): Saves the entity but does not immediately push changes to the database.
saveAndFlush(): Saves the entity and immediately flushes changes to the database.

save: Use it when you’re making multiple changes and you want to batch the database operations together for performance reasons. The actual database update happens only at the end of the transaction or when you explicitly flush the session.

saveAndFlush: Use it when you need to ensure that the changes are immediately visible in the database. This is useful if you need to perform some operation that depends on the persisted state of the entity right away.


Q.put vs patch.
-->
put :- Replaces the entire resource with the provided data. If any fields are missing, they are overwritten with null or default values.
       entire object /entity

patch:- Only updates specific fields of a resource. Fields not provided remain unchanged.
        Used to partially update a resource.




1)@Configuration :-
@Configuration is an annotation that indicates that the class contains bean definitions,
while @Bean is used to define specific beans.
Configuration annotations simplify setup by allowing developers to define configuration
can define more than one beans inside it.

2)@ComponentScan:-
@ComponentScan instructs Spring to scan specified packages for components,
so they can be automatically managed by the Spring container.
-->
 is a Spring Framework annotation used to automatically detect and register beans (classes annotated with @Component, @Service, @Repository, etc.) in the application context.
 It tells Spring where to look for components and configurations by specifying the base packages to scan.

my==it scans only the current package under java package for creating beans
                 if u define another package then there will be no springbootapplication class so componentscan
                 cannot scan that class and not be able to create objects by springcontainer. :-.NoSuchBeanDefinitionException
                 so define subpackage name inside @cs("package name") , now will create a bean





3)@Bean:- diff. in component and bean
inside bean we can define our object creation logic like how to create object for particular class
but , in component bean is created automatically by spring container by using constructor




4) @Qualifier is used to specify which bean to inject when multiple beans of the same type are available.
 It helps resolve ambiguity by providing an additional identifier to distinguish between beans.


suppose you have one interface with incomplete method inside it called as test() but it has 2 impl classes
so while creating a bean it will give error like :-
beans cannot be found due to multiple definations of one interface

5)@RestController :- @ResponseBody & @Controller

6)PropertySource :-
annotation is used to provide properties file to Spring Environment.
This annotation is used with @Configuration classes.
Spring PropertySource annotation is repeatable, means you can have multiple PropertySource on a Configuration class.
Errors :--- UnsatisfiedDependencyException, BeanCreationException
for eg:- for twilio config sid,account number everything which is written in manual/my properties file then
         to read the values inside config class we need to use this annotation
         @PropertySource("classpath:my.properties")
         so we can create as many as properties file as we want

Q. if account_id field is declared in both app.properties and my.properties
   then inside configuration class which properties id will it read out?
-->
it will definitely read app.properties only as it is default one even if we use annotation.


7) @Transient :- field will not save it into the database

8) @ConditionalOnProperty(name = "feature.enabled", havingValue = "true")
It's often applied in configuration classes to conditionally create beans.
is an annotation used in Spring Boot for conditional bean registration based on the presence or value of specific properties in the application’s configuration (like application.properties or application.yml).
//can be used on configuration class, or with the bean methods

9)@EntityListeners:-
Eg. @EntityListeners(value = ItemListener.class)

@PrePersist
@PostPersist
@PreUpdate
@PostUpdate
@PreRemove
@PostRemove




































